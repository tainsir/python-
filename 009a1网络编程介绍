# 1. 日志：编写一个基于网络通信的C/S架构的软件
#
# C/S: Client(客户端)------基于网络------server（服务端）
# B/S: Browser(浏览器)------基于网络------server
#
# 2.服务器应该遵循的原则:
#     1.服务端与客户端都需要有唯一的地址，但是服务器的地址必须固定/绑定
#     2.对外一直提供服务，稳定运行
#     3.服务端应该支持并发（多个用户端同事访问）



#       ip+mac可以标识全世界范围内独一无二的一台计算机的位置
#       port可以标识一台计算机之上唯一的一个基于网络通信的应用软件
#       ip+mac+port: 可以标识全世界范围内独一无二的一个应用软件(基于网络通信)


# 3.网络
#      网络=底层的物理连接介质+互联网协议
#     网络建立的目的是为了数据交互(通信)
#     如何实现通信：
#         1.建立好底层的物理连接介质
#         2.有一套统一的通信标准，称之为互联网协议

# 4.互联网协议：就是一套标准通用的软件，计算机界的英语
#     OSI七层协议
#       应用层（应用层、表示层、会话层这三层）：http,ftp
#       传输层 ：tcp/udp
#       网络层：ip
#       数据链路层：ethernet
#       物理层：发送电信号


# 数据链路层：
    #     以太网协议ethernet：
    #         一组电信号构成一个数据包，叫做‘帧’
    #         每一数据帧分成：报头head和数据data两部分

    #     head包含：(固定18个字节)
    #         发送者／源地址，6个字节
    #         接收者／目标地址，6个字节
    #         数据类型，6个字节
    #     data包含：(最短46字节，最长1500字节)
    #         数据包的具体内容
    #     head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送

    #     mac地址：
    #     head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，
    #     发送端和接收端的地址便是指网卡的地址，即mac地址
    #     mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，
    #     通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）


    #     广播：
    #     有了mac地址，同一网络内的两台主机就可以通信了（一台主机通过arp协议获取另外一台主机的mac地址）
    #     ethernet采用最原始的方式，广播的方式进行通信


# 网络层
    # IP协议：
    # 规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示
    # 范围0.0.0.0-255.255.255.255
    # 一个ip地址通常写成四段十进制数，例：172.16.10.1

    # ip地址分成两部分
    # 网络部分：标识子网
    # 主机部分：标识主机
    # 注意：单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网
    # 例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网

    # 子网掩码
    # 所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。
    # 比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，
    # 写成十进制就是255.255.255.0。

    # IP协议的两个作用：  1.为每一台计算机分配IP地址
    #                   2.确定哪些地址在同一个子网络

    # ARP协议（了解）
    # 计算机通信基于mac的广播方式，计算机在发包时，获取自身的mac是容易的，如何获取目标主机的mac，就需要通过arp协议
    # arp协议功能：广播的方式发送数据包，获取目标主机的mac地址

    # 协议工作方式：每台主机ip都是已知的
    # 一：首先通过ip地址和子网掩码区分出自己所处的子网
            #     场景               数据包地址
            # 同一子网                目标主机mac，目标主机ip
            # 不同子网                网关mac，目标主机ip
    # 二：分析172.16.10.10/24与172.16.10.11/24处于同一网络(如果不是同一网络，那么下表中目标ip为172.16.10.1,通过arp获取的是网关的mac)


# 传输层：建立端口到端口的通信
# 端口范围0-65535，0-1023为系统占用端口
# tcp协议：
# 可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，
# 通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。
# 以太网头	ip 头              	tcp头              	数据
#
# udp协议：
# 不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。
# 以太网头	ip头                 udp头               数据
# tcp报文
# tcp建链接三次握手、数据传输、断链接四次挥手

  # 大公司面试：
  #     http://www.cnblogs.com/linhaifeng/articles/5937962.html
  #     http://www.cnblogs.com/linhaifeng/articles/6129246.html
        # tcp建链接三次握手（需要了解）
        # 数据传输  why可靠？（需要了解）   tcp数据传输阶段发请求可靠，有响应，udp不管回应，狂发送到服务器，不可靠
        # 断链接四次挥手 （需要了解）
        # 半链接池限制的是请求数目，不是链接数量


        # 域名，解析成端口，
        # 域名+ip，url地址 应用层用tcp协议

# 应用层：规定应用程序的数据格式。
# 例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。
# 那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，
# 这些应用程序协议就构成了”应用层”。


# socket（套接字）内部封装了TCP/IP

# 想实现网络通信，每台主机需具备四要素：
# 本机的IP地址
# 子网掩码
# 网关的IP地址
# DNS的IP地址
# http://www.cnblogs.com/linhaifeng/articles/5937962.html
# osi七层图
# http://www.cnblogs.com/linhaifeng/articles/6129246.html#_label4
# socket层图
# 套接字工作流程图


# =======================/=========================================
# 服务端套接字函数
# s.bind()    绑定(主机,端口号)到套接字
# s.listen()  开始TCP监听
# s.accept()  被动接受TCP客户的连接,(阻塞式)等待连接的到来
#
# 客户端套接字函数
# s.connect()     主动初始化TCP服务器连接
# s.connect_ex()  connect()函数的扩展版本,出错时返回出错码,而不是抛出异常
#
# 公共用途的套接字函数
# s.recv()            接收TCP数据
# s.send()            发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)
# s.sendall()         发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)
# s.recvfrom()        接收UDP数据
# s.sendto()          发送UDP数据
# s.getpeername()     连接到当前套接字的远端的地址
# s.getsockname()     当前套接字的地址
# s.getsockopt()      返回指定套接字的参数
# s.setsockopt()      设置指定套接字的参数
# s.close()           关闭套接字
#
# 面向锁的套接字方法
# s.setblocking()     设置套接字的阻塞与非阻塞模式
# s.settimeout()      设置阻塞套接字操作的超时时间
# s.gettimeout()      得到阻塞套接字操作的超时时间
#
# 面向文件的套接字的函数
# s.fileno()          套接字的文件描述符
# s.makefile()        创建一个与该套接字相关的文件

# =======================/=========================================
# 基于TCP的套接字
# tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端
#
# tcp服务端
# ss = socket() #创建服务器套接字
# ss.bind()      #把地址绑定到套接字
# ss.listen()      #监听链接
# inf_loop:      #服务器无限循环
# cs = ss.accept() #接受客户端链接
# comm_loop:         #通讯循环
# cs.recv()/cs.send() #对话(接收与发送)
# cs.close()    #关闭客户端套接字
# ss.close()        #关闭服务器套接字(可选)


# tcp客户端
# cs = socket()    # 创建客户套接字
# cs.connect()    # 尝试连接服务器
# comm_loop:        # 通讯循环
# cs.send()/cs.recv()    # 对话(发送/接收)
# cs.close()            # 关闭客户套接字


