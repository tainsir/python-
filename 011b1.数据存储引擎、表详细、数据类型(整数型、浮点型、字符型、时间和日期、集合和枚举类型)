1.数据存储引擎
    什么是引擎 ? 一个功能的核心部分
    引擎可以被分类
    为什么要分类?
        自然  增压的  汽油  柴油 电动 混合动力 天然气  核动力 烧水
        汽油  动力弱一点  噪音小 震动小
        柴油  动力强  污染大  噪音大 振动大
      需求场景的不同催生了不同的引擎类别

     回到mysql
        核心功能是存储数据  涉及到存储数据的代码 就称之为存储引擎
        根据不同的需求 也有着不同的引擎分类

      不同的引擎测试
      创建表时在最后指定引擎名称  engine = xxx
      create table t1(id int)engine=innodb
      create table t1(id int not null)engine=csv
      create table t1(id int)engine=memory
      create table t1(id int)engine=blackhole
      insert into t1 value(1);
      insert into t2 value(1);
      insert into t3 value(1);
      insert into t4 value(1);

    总结: innodb是默认的引擎 因为 它是永久存储 并且  支持事务,行锁,外键

2.创建表的完整语句


3.数据类型

========================================================================
表详细

创建表的完整语法
create table 表名(
字段名称 数据类型[(长度) 约束条件],
字段名称 数据类型[(长度) 约束条件]
)   *****


必须的:字段名  数据类型  表名  *****
可选的:长度 约束条件         *****

长度用于设置数据的长度

数据类型也是一种约束
约束指的是除了数据类型外的额外的规范

如果添加的数据超过了指定的长度范围,超出范围的就丢弃;

注意: 字段名 和 表名  库名  都不能是mysql的关键字 比如select from not.....  *****

===============================================================================

数据类型
    为什么需要将数据分类?
        1.为了描述事物 更加准确
        2.描述起来更方便
        3.节省内存空间
            1  a  你
            utf8  下 5个字节
            1 a b c
            unicode 6个字节

    mysql支持的数据类型:

        整型
               ***      ***     ***    *****   ***
            tinyint smallint mediumint  int   bigint
         字节数:1       2         3      4     8
        默认情况下整型是有符号的 需要用一个二进制位存储符号
        给整型加上 约束 unsigned来表示无符号
        如果数据超出范围就尽可能保存最大的 例如 在无符号下 保存256  其实存的255
        如果有符号  例如 tinyint  保存-1280 其实存的是-128  是最小值

        修改严格模式:
        以上特性的出现是因为 mysql处于非严格模式
            查看当前模式  show variables like "sql_mode";
            修改为严格模式  set global sql_mode = "STRICT_TRANS_TABLES";
        严格模式下 如果值超出范围就直接报错,在一些版本中默认就是严格模式!
            在我们的正常开发中,我们应该先判断数据的正确性,没有问题在发给数据库

        怎么选择: 得根据实际情况来判断,能够保存你的数据的最小类型

        长度限制对于整型的意义:
            create table t10(id int(1));
            insert into t10 value(454555);
            select *from t10;
            发现这个数也存储成功
            说明 这里长度指的不是存储容量限制
            而是显示的宽度
            如果你的数据超过了显示宽度 有几个显示几个
            如果不足 则补全到指定长度  得告诉它用什么来补全
            create table t13(id int(10) zerofill);
           总结 不是容量限制 而是 显示宽度
                要限制显示宽度
                 1.创建表时 给整型加上宽度
                 2.加上zerofill约束

==============================================================================
        浮点型

        浮点型: 小数型

分类: float *****  double **** decimal  *****
字节数:     4          8        不确定(手动指定)

给浮点设置宽度限制
float(m,d)
double(m,d)
decimal(m,d)

长度说明 *****
m表示 这个浮点数整体的长度
d表示 小数部分的长度
例如: float(5,3)  最大值: 99.999


区别 *****
相同点: 小数部分最大长度都是30
        float和double的最大长度为255
不同点: decimal的整体最大长度65
        精度不同
        double 比 float 精度高
        decimal 是准确的 不会丢失精度

如何选择:你对精确度要求高你就使用 decimal

==================================================================================
        字符串

        字符型
分类
char  定长字符
varchar 变长字符

char类型的长度是固定 无论你存储的数据有多长 占用的容量都一样
char(3)  存储的数据为 "a"   在硬盘保存的数据还是占3字符长度  实际保存的是"a  "
varchar 长度是可变的 存储的数据有多长就占用多长
varchar(3)  存储的数据为 "a" 在硬盘保存的数据还是占1字符长度  实际保存的是"a"
yxx exx lxx zxx cx wxx   char(3)
(1bytes+yx)(1bytes+exx)(1bytes+lx)(1bytes+zxx)  varchar(3)
如果是可变长度 则有问题 不知道数据从哪里开始到哪里结束  所以需要有一个位置保存数据的长度
vharchar 能支持的最大长度是65535  用于保存数据长度的数据最长两个bytes


如果是char类型  如果你的数据不足指定长度 就在后面用空格补全

验证:
    使用一个 char_length的函数 可以查看字符的长度
    create table t18(a char(4),b varchar(4));
    insert into t18 value("x","x");
    select char_length(a),char_length(b) from t18;
    两个字段的长度都为1

    结论:
    这是因为 mysql在存储时 自动加上的空格 对使用者而言是没有意义的 所以mysql自动帮你处理掉空格了
    我们可以设置sql模式 来让它现出原形
    set global sql_mode = "PAD_CHAR_TO_FULL_LENGTH,STRICT_TRANS_TABLES"
    设置完成后重启msyql 再次查询长度

    注意:
    当你在执行这样的查询语句时  mysql会自动将参数末尾的空格去除
    select *from t19 where  name = "yh"
    当你在使用模糊搜索时 要注意 定长字符 后面可能会有空格 所以最好在后面加上百分号 %
    select *from t19 where  name like "yh";
        % 任意个数的任意字符
        _ 1个任意字符

如何选择
    char
        存取效率高
        浪费存储空间
    varchar
        存取效率低于char
        节省存储空间
    使用起来感受不到区别 通常用的是char



char和varchar 长度都比较小 最大就是65535

    大文本类型:
    TEXT系列 TINYTEXT TEXT MEDIUMTEXT LONGTEXT     文本是带有编码
    BLOB 系列    TINYBLOB BLOB MEDIUMBLOB LONGBLOB 也是字符数据 但是不带编码

    二进制类型: 用于存储多媒体数据 比如视频   但是我们一般不会将多媒体数据存到数据 而是存储文件路径地址
    BINARY系列 BINARY VARBINARY    存储二进制数据

==================================================================================
        时间日期

分类
time   时分秒   HH:MM:SS   ***
year   年份     ***
date   日期  年月日   ***
datetime 日期加时间 年月日 时分秒     年份最大是9999    *****
timestamp 时间戳  从1970-1-1开始算    年份最大是2037    *****


共同点: 时间的存取通过字符串类型
        都可以使用now()函数来插入当前时间


datetime 和 时间戳都能够表示日期和时间
不同之处是: 年份最大范围不同
            时间戳可以为空 代表当前时间
            时间戳在你更新记录时 会自动更新为当前时间

==========================================================================
        布尔  可以用别的类型;来代替
=================================================================================
        集合和枚举
枚举  **
    用于描述 一个已知范围的数据 例如性别: 只有男 女 或其他
    enum("man","woman","other")

    总结: 枚举中只能是字符串类型
          添加的数据只能是已经出现在枚举中的值
          你的值只能是其中的一个
          你也可以使用枚举值的序号来插入值 从1开始
           多选一
集合 **
    用于描述一堆数据  比如你的兴趣爱好
    set("watch movie","listen music","play game")

    总结:集合中的数据 只能是字符串
         添加的数据只能是已经出现在集合中的值
         你的值可以是其中的任意几个
         你也可以使用枚举值的序号来插入值 从1开始   但是只能给一个序号
           多选多















